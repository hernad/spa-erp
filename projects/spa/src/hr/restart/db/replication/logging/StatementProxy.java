/****license*****************************************************************
**   file: StatementProxy.java
**   Copyright 2006 Rest Art
**
**   Licensed under the Apache License, Version 2.0 (the "License");
**   you may not use this file except in compliance with the License.
**   You may obtain a copy of the License at
**
**       http://www.apache.org/licenses/LICENSE-2.0
**
**   Unless required by applicable law or agreed to in writing, software
**   distributed under the License is distributed on an "AS IS" BASIS,
**   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
**   See the License for the specific language governing permissions and
**   limitations under the License.
**
****************************************************************************/
/*
 * Created on 07-Oct-2004
 *
 */
package hr.restart.db.replication.logging;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import org.apache.log4j.Logger;

/**
 * @author gradecak
 *
 *TODO : when cancelling or deleting a statement or whatever it should be deleted from the LOG 
 * execution too.
 */
class StatementProxy implements Statement{
	private Statement statement = null;	
	private ConnectionProxy connection = null;
	private Logger log = null;

	//private StringBuffer sql = null;

	/**
	 * 
	 */
	public StatementProxy(Statement statement) {

		setStatement(statement);
		//sql = new StringBuffer();
		
		log = Logger.getLogger(StatementProxy.class);
		
		log.debug("StatementProxy created");
	}
	
	/* (non-Javadoc)
	 * @see java.sql.Statement#addBatch(java.lang.String)
	 */
	public void addBatch(String sql) throws SQLException {
		throw new UnsupportedOperationException("This method is not implemented. According to the java.sql.Statement specification : A driver is not required to implement this method");
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#cancel()
	 */
	public void cancel() throws SQLException {
	    throw new UnsupportedOperationException("Not supported method");
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#clearBatch()
	 */
	public void clearBatch() throws SQLException {
		throw new UnsupportedOperationException("This method is not implemented. According to the java.sql.Statement specification : A driver is not required to implement this method");
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#clearWarnings()
	 */
	public void clearWarnings() throws SQLException {
		getStatement().clearWarnings();
		
		log.debug("StatementProxy.clearWarnings()");
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#close()
	 */
	public void close() throws SQLException {
	    try{
		    //connection.removeStatement(this);
			getStatement().close();
			log.debug("StatementProxy.close()");
	    }catch(RuntimeException e){
	        throw new SQLException(e.getMessage());
	    }
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#execute(java.lang.String, int)
	 */
//	public boolean execute(String sql, int autoGeneratedKeys)
//			throws SQLException {
//	    
//	    if(getConnection().getAutoCommit())
//		    ((ConnectionProxy)getConnection()).beginTransaction();
//		
//		boolean ret = getStatement().execute(sql, autoGeneratedKeys);
//		
//		//connection.executeLOG(this.sql.toString());
//		addSql(sql);
//
//
//		if(getConnection().getAutoCommit()){
//		    getConnection().commit();
//		    log.info("logged : "+sql);									
//		}
//		
////		else 			
////			((ConnectionProxy)getConnection()).addSQL(sql);
//		
//		log.debug("StatementProxy.execute("+sql+","+autoGeneratedKeys+") == "+ret);		
//		return ret;
//	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#execute(java.lang.String, int[])
	 */
//	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
//	    
//	    if(getConnection().getAutoCommit())
//		    ((ConnectionProxy)getConnection()).beginTransaction();
//	    
//		boolean ret = getStatement().execute(sql, columnIndexes);		
//		addSql(sql);
//		
//		//connection.executeLOG(this.sql.toString());		
//		
//		if(getConnection().getAutoCommit()){
//		    getConnection().commit();
//		    log.info("logged : "+sql);									
//		}
////		else 			
////			((ConnectionProxy)getConnection()).addSQL(sql);
//		
//		log.debug("StatementProxy.execute("+sql+","+columnIndexes+") == "+ret);
//		
//		return ret;
//	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#execute(java.lang.String, java.lang.String[])
	 */
//	public boolean execute(String sql, String[] columnNames)
//			throws SQLException {
//	    
//	    if(getConnection().getAutoCommit())
//		    ((ConnectionProxy)getConnection()).beginTransaction();
//	    
//		boolean ret = getStatement().execute(sql, columnNames);		
//		addSql(sql);
//		
//		//connection.executeLOG(this.sql.toString());
//		
//		log.debug("StatementProxy.execute("+sql+","+columnNames+") == "+ret);
//		
//		if(getConnection().getAutoCommit()){
//		    getConnection().commit();
//			log.info(sql);		
//		}
////		else 			
////			((ConnectionProxy)getConnection()).addSQL(sql);
//		
//		return ret;
//	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#execute(java.lang.String)
	 */
	public boolean execute(String sql) throws SQLException {	    	    
		
	    if(getConnection().getAutoCommit())
		    ((ConnectionProxy)getConnection()).beginTransaction();
						
		boolean ret = getStatement().execute(sql);
		addSql(sql);
		
		//connection.executeLOG(this.sql.toString());				
		
		if(getConnection().getAutoCommit()){
		    getConnection().commit();
			log.info(sql);
		}
		
//		else 			
//			((ConnectionProxy)getConnection()).addSQL(sql);
		
		log.debug("StatementProxy.execute("+sql+") == "+ret);
		
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#executeBatch()
	 */
	public int[] executeBatch() throws SQLException {
		throw new UnsupportedOperationException("This method is not implemented. According to the java.sql.Statement specification : A driver is not required to implement this method");
		// TODO : the problem is when executing this method, we have no access on it. so we do not implement it for now.
		//			A solution can be to call execute(sql) for each element taht is stored in a local list, but then we 
		//			should return the good values as it is said in the interface's specification.
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#executeQuery(java.lang.String)
	 */
	public ResultSet executeQuery(String sql) throws SQLException {
	    
//	    if(getConnection().getAutoCommit())
//		    ((ConnectionProxy)getConnection()).beginTransaction();
	    
		ResultSet ret = getStatement().executeQuery(sql);
		
//		if(getConnection().getAutoCommit())
//		    getConnection().commit();
		
//		if(isAutoCommit() == true)
//			log(sql);
//		else 			
//			((ConnectionProxy)getConnection()).addSQL(sql);
		
		log.debug("StatementProxy.executeQuery("+sql+") == "+ret);
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#executeUpdate(java.lang.String, int)
	 */
//	public int executeUpdate(String sql, int autoGeneratedKeys)
//			throws SQLException {
//	    
//	    if(getConnection().getAutoCommit())
//		    ((ConnectionProxy)getConnection()).beginTransaction();
//	    
//		int ret = getStatement().executeUpdate(sql, autoGeneratedKeys);		
//		addSql(sql);
//		
//		//connection.executeLOG(this.sql.toString());
//		
//		if(getConnection().getAutoCommit()){
//		    getConnection().commit();
//			log.info(sql);
//		}
////		else 			
////			((ConnectionProxy)getConnection()).addSQL(sql);
//		
//		log.debug("StatementProxy.executeUpdate("+sql+","+autoGeneratedKeys+")== "+ret);
//		
//		return ret;
//	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#executeUpdate(java.lang.String, int[])
	 */
//	public int executeUpdate(String sql, int[] columnIndexes)
//			throws SQLException {
//	    
//	    if(getConnection().getAutoCommit())
//		    ((ConnectionProxy)getConnection()).beginTransaction();
//	    
//		int ret = getStatement().executeUpdate(sql, columnIndexes);
//		addSql(sql);
//		
//		//connection.executeLOG(this.sql.toString());
//		
//		
//		if(getConnection().getAutoCommit()){
//		    getConnection().commit();
//			log.info(sql);
//		}
////		else 			
////			((ConnectionProxy)getConnection()).addSQL(sql);
//		
//		log.debug("StatementProxy.executeUpdate("+sql+","+columnIndexes+") == "+ret);
//		
//		return ret;
//	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#executeUpdate(java.lang.String, java.lang.String[])
	 */
//	public int executeUpdate(String sql, String[] columnNames)
//			throws SQLException {
//	    
//	    if(getConnection().getAutoCommit())
//		    ((ConnectionProxy)getConnection()).beginTransaction();
//	    
//		int ret = getStatement().executeUpdate(sql, columnNames);
//		addSql(sql);
//		
//		//connection.executeLOG(this.sql.toString());
//		
//		if(getConnection().getAutoCommit()){
//		    getConnection().commit();
//			log.info(sql);
//		}
////		else 			
////			((ConnectionProxy)getConnection()).addSQL(sql);
//		
//		log.debug("StatementProxy.executeUpdate("+sql+","+columnNames+")");
//		
//		return ret;
//	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#executeUpdate(java.lang.String)
	 */
	public int executeUpdate(String sql) throws SQLException {
	    
	    if(getConnection().getAutoCommit())
		    ((ConnectionProxy)getConnection()).beginTransaction();
	    
		int ret = getStatement().executeUpdate(sql);
		addSql(sql);
		
		//connection.executeLOG(this.sql.toString());
		
		if(getConnection().getAutoCommit()){
		    getConnection().commit();
			log.info(sql);
		}
//		else 			
//			((ConnectionProxy)getConnection()).addSQL(sql);
		
		log.debug("StatementProxy.executeUpdate("+sql+")");
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getConnection()
	 */
	public Connection getConnection() throws SQLException {				
		log.debug("StatementProxy.getConnection() == "+this.connection);
		
		return this.connection;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getFetchDirection()
	 */
	public int getFetchDirection() throws SQLException {
		int ret = getStatement().getFetchDirection();
		
		log.debug("StatementProxy.getFetchDirection() == "+ret);
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getFetchSize()
	 */
	public int getFetchSize() throws SQLException {
		int ret = getStatement().getFetchSize();
		
		log.debug("StatementProxy.getFetchSize() == "+ret);
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getGeneratedKeys()
	 */
//	public ResultSet getGeneratedKeys() throws SQLException {
//		ResultSet ret = getStatement().getGeneratedKeys();
//		
//		log.debug("StatementProxy.getGenerateKeys() == "+ret);
//		
//		return ret;
//	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getMaxFieldSize()
	 */
	public int getMaxFieldSize() throws SQLException {
		int ret = getStatement().getMaxFieldSize();
		
		log.debug("StatementProxy.getMaxFieldSize() == "+ret);
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getMaxRows()
	 */
	public int getMaxRows() throws SQLException {
		int ret = getStatement().getMaxRows();
		
		log.debug("StatementProxy.getMaxRows() == "+ret);
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getMoreResults()
	 */
	public boolean getMoreResults() throws SQLException {
		boolean ret = getStatement().getMoreResults();
		log.debug("StatementProxy.getMoreResults() == "+ret);
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getMoreResults(int)
	 */
//	public boolean getMoreResults(int current) throws SQLException {
//		boolean ret = getStatement().getMoreResults(current);
//		
//		log.debug("StatementProxy.getMoreResults("+current+") == "+ret);
//		
//		return ret;
//	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getQueryTimeout()
	 */
	public int getQueryTimeout() throws SQLException {
		int ret = getStatement().getQueryTimeout();		
		
		log.debug("StatementProxy.getQueryTimeout() == "+ret);
			
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getResultSet()
	 */
	public ResultSet getResultSet() throws SQLException {
		ResultSet ret = getStatement().getResultSet();
		
		log.debug("StatementProxy.getResultSet() == "+ret);
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getResultSetConcurrency()
	 */
	public int getResultSetConcurrency() throws SQLException {
		int ret = getStatement().getResultSetConcurrency();
		
		log.debug("StatementProxy.getresultSetConcurrency() == "+ret);
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getResultSetHoldability()
	 */
//	public int getResultSetHoldability() throws SQLException {
//		int ret = getStatement().getResultSetHoldability();
//		
//		log.debug("StatementProxy.getResultSetHoldability() == "+ret);
//		
//		return ret;
//	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getResultSetType()
	 */
	public int getResultSetType() throws SQLException {
		int ret = getStatement().getResultSetType();
		
		log.debug("StatementProxy.getResultSetType() == "+ret);
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getUpdateCount()
	 */
	public int getUpdateCount() throws SQLException {
		int ret = getStatement().getUpdateCount();
		
		log.debug("StatementProxy.getUpdateCount() == "+ret);
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#getWarnings()
	 */
	public SQLWarning getWarnings() throws SQLException {
		SQLWarning ret = getStatement().getWarnings();
		
		log.debug("StatementProxy.getWarnings() == "+ret);
		
		return ret;
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#setCursorName(java.lang.String)
	 */
	public void setCursorName(String name) throws SQLException {
		getStatement().setCursorName(name);
		
		log.debug("StatementProxy.setCursorName("+name+")");
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#setEscapeProcessing(boolean)
	 */
	public void setEscapeProcessing(boolean enable) throws SQLException {
		getStatement().setEscapeProcessing(enable);
		log.debug("Statement.setEscapeProcessing("+enable+"");
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#setFetchDirection(int)
	 */
	public void setFetchDirection(int direction) throws SQLException {
		getStatement().setFetchDirection(direction);
		
		log.debug("StatementProxy.setFetchDirection("+direction+")");
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#setFetchSize(int)
	 */
	public void setFetchSize(int rows) throws SQLException {
		getStatement().setFetchSize(rows);
		
		log.debug("Statement.setFetchSize("+rows+")");
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#setMaxFieldSize(int)
	 */
	public void setMaxFieldSize(int max) throws SQLException {
		getStatement().setMaxFieldSize(max);
		
		log.debug("StatementProxy.setMaxFieldSize("+max+")");
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#setMaxRows(int)
	 */
	public void setMaxRows(int max) throws SQLException {
		getStatement().setMaxRows(max);
		
		log.debug("StatementProxy.setMaxRows("+max+")");
	}
	/* (non-Javadoc)
	 * @see java.sql.Statement#setQueryTimeout(int)
	 */
	public void setQueryTimeout(int seconds) throws SQLException {
		getStatement().setQueryTimeout(seconds);
		
		log.debug("StatementProxy.setQueryTimeout("+seconds+")");
	}
	/**
	 * @return Returns the statement.
	 */
	private Statement getStatement() {
		return statement;
	}
	/**
	 * @param statement The statement to set.
	 */
	private void setStatement(Statement statement) {
		this.statement = statement;
	}
	/**
	 * @param connection The connection to set.
	 */
	synchronized public void setConnection(ConnectionProxy connection) {
		if(this.connection != null)
			throw new IllegalArgumentException("The connection cannot be setted because it is already setted");
		
		this.connection = connection;
	}
		 
	private void addSql(String sql) throws SQLException{
	    
//	    connection.addStatement(this);
//	    
//	    this.sql.append(sql+"*\n\r#");
	    
	    connection.executeLOG(sql);
	}
//    /* (non-Javadoc)
//     * @see hr.restart.db.replication.logging.IStatementProxy#getSql()
//     */
//    public String getSqlLog() {
//        return sql.toString();
//    }
//    
//    
//    /* (non-Javadoc)
//     * @see hr.restart.db.replication.logging.IStatementProxy#clearSqlLog()
//     */
//    public void clearSqlLog(int length) {
//       sql.delete(0, length);        
//    }

  public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
    // TODO Auto-generated method stub
    return false;
  }

  public boolean execute(String sql, int[] columnIndexes) throws SQLException {
    // TODO Auto-generated method stub
    return false;
  }

  public boolean execute(String sql, String[] columnNames) throws SQLException {
    // TODO Auto-generated method stub
    return false;
  }

  public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
    // TODO Auto-generated method stub
    return 0;
  }

  public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
    // TODO Auto-generated method stub
    return 0;
  }

  public int executeUpdate(String sql, String[] columnNames) throws SQLException {
    // TODO Auto-generated method stub
    return 0;
  }

  public ResultSet getGeneratedKeys() throws SQLException {
    // TODO Auto-generated method stub
    return null;
  }

  public boolean getMoreResults(int current) throws SQLException {
    // TODO Auto-generated method stub
    return false;
  }

  public int getResultSetHoldability() throws SQLException {
    // TODO Auto-generated method stub
    return 0;
  }
}
